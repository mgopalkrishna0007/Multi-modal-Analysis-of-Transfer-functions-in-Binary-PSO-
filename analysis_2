import numpy as np
import matplotlib.pyplot as plt
import os
import math
import time
from scipy.special import erf
from datetime import datetime

# Create main output directory with timestamp
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
main_output_dir = f"BPSO_Final_Results_{timestamp}"
os.makedirs(main_output_dir, exist_ok=True)

# Create subdirectories
convergence_dir = os.path.join(main_output_dir, "1_Convergence_Plots")
results_dir = os.path.join(main_output_dir, "2_Results_Data")
performance_dir = os.path.join(main_output_dir, "3_Performance_Plots")

for directory in [convergence_dir, results_dir, performance_dir]:
    os.makedirs(directory, exist_ok=True)

# Benchmark functions definitions
benchmark_functions = [
    {"name": "F1: Shifted sphere", 
     "func": lambda x: np.sum((x - 50)**2) + 450,
     "range": [-100, 100], "dim": 5, "fmin": 450},
    
    {"name": "F2: Shifted Schwefel", 
     "func": lambda x: np.sum((x - 50)**2) + 450,
     "range": [-100, 100], "dim": 5, "fmin": 450},
    
    {"name": "F3: Shifted rotated elliptic", 
     "func": lambda x: np.sum([1000**(i/(len(x)-1)) * (x[i]-50)**2 for i in range(len(x))]) + 450,
     "range": [-100, 100], "dim": 5, "fmin": 450},
    
    {"name": "F4: Shifted Schwefel with noise", 
     "func": lambda x: np.sum((x - 50)**2) * (1 + 0.1 * np.random.normal(0, 1)) + 450,
     "range": [-100, 100], "dim": 5, "fmin": 450},
    
    {"name": "F5: Schwefel global opt bound", 
     "func": lambda x: 418.9829 * len(x) - np.sum(x * np.sin(np.sqrt(np.abs(x)))) + 310,
     "range": [-100, 100], "dim": 5, "fmin": 310},
    
    {"name": "F6: Shifted Rosenbrock", 
     "func": lambda x: np.sum(100 * (x[1:] - x[:-1]**2)**2 + (x[:-1] - 1)**2) + 390,
     "range": [-100, 100], "dim": 5, "fmin": 390},
    
    {"name": "F7: Shifted rotated Griewank", 
     "func": lambda x: np.sum((x - 300)**2)/4000 - np.prod([np.cos((x[i]-300)/np.sqrt(i+1)) for i in range(len(x))]) + 1 + 180,
     "range": [0, 600], "dim": 5, "fmin": 180},
    
    {"name": "F8: Shifted rotated Ackley", 
     "func": lambda x: -20*np.exp(-0.2*np.sqrt(np.sum((x-32)**2)/len(x))) - np.exp(np.sum(np.cos(2*np.pi*(x-32)))/len(x)) + 20 + np.e + 140,
     "range": [-32, 32], "dim": 5, "fmin": 140},
    
    {"name": "F9: Shifted Rastrigin", 
     "func": lambda x: 10*len(x) + np.sum((x-2.5)**2 - 10*np.cos(2*np.pi*(x-2.5))) + 330,
     "range": [-5, 5], "dim": 5, "fmin": 330},
    
    {"name": "F10: Shifted rotated Rastrigin", 
     "func": lambda x: 10*len(x) + np.sum((x-2.5)**2 - 10*np.cos(2*np.pi*(x-2.5))) + 330,
     "range": [-5, 5], "dim": 5, "fmin": 330},
    
    {"name": "F11: Shifted rotated Weierstrass", 
     "func": lambda x: sum([sum([0.5**k * np.cos(2*np.pi*3**k*(x[i]-0.25+0.5)) for k in range(21)]) for i in range(len(x))]) - len(x)*sum([0.5**k * np.cos(2*np.pi*3**k*0.5) for k in range(21)]) + 90,
     "range": [-0.5, 0.5], "dim": 5, "fmin": 90},
    
    {"name": "F12: Schwefel", 
     "func": lambda x: 418.9829 * len(x) - np.sum(x * np.sin(np.sqrt(np.abs(x)))) + 460,
     "range": [-100, 100], "dim": 5, "fmin": 460},
    
    {"name": "F13: Expanded Griewank+Rosenbrock", 
     "func": lambda x: (1 + np.sum(x**2)/4000 - np.prod([np.cos(x[i]/np.sqrt(i+1)) for i in range(len(x))]) + np.sum(100*(x[1:]-x[:-1]**2)**2 + (x[:-1]-1)**2))/2 + 130,
     "range": [-3, 1], "dim": 5, "fmin": 130},
    
    {"name": "F14: Shifted rotated expanded Scaffer", 
     "func": lambda x: sum([0.5 + (np.sin(np.sqrt((x[i]-50)**2 + (x[(i+1)%len(x)]-50)**2))**2 - 0.5)/(1 + 0.001*((x[i]-50)**2 + (x[(i+1)%len(x)]-50)**2))**2 for i in range(len(x))]) + 300,
     "range": [-100, 100], "dim": 5, "fmin": 300},
    
    {"name": "F15: Hybrid composition", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 120,
     "range": [-5, 5], "dim": 10, "fmin": 120},
    
    {"name": "F16: Rotated hybrid composition", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 120,
     "range": [-5, 5], "dim": 10, "fmin": 120},
    
    {"name": "F17: Rotated hybrid composition with noise", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) * (1 + 0.1*np.random.normal(0, 1)) + 120,
     "range": [-5, 5], "dim": 10, "fmin": 120},
    
    {"name": "F18: Rotated hybrid composition function", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 10,
     "range": [-5, 5], "dim": 10, "fmin": 10},
    
    {"name": "F19: Rotated hybrid composition with narrow basin", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 10,
     "range": [-5, 5], "dim": 10, "fmin": 10},
    
    {"name": "F20: Rotated hybrid composition with global opt on bounds", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 10,
     "range": [-5, 5], "dim": 10, "fmin": 10},
    
    {"name": "F21: Rotated hybrid composition function", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 360,
     "range": [-5, 5], "dim": 10, "fmin": 360},
    
    {"name": "F22: Rotated hybrid composition with high condition number", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 360,
     "range": [-5, 5], "dim": 10, "fmin": 360},
    
    {"name": "F23: Non-continuous rotated hybrid composition", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 360,
     "range": [-5, 5], "dim": 10, "fmin": 360},
    
    {"name": "F24: Rotated hybrid composition function", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 260,
     "range": [-5, 5], "dim": 10, "fmin": 260},
    
    {"name": "F25: Rotated hybrid composition without bounds", 
     "func": lambda x: np.sum(x**2 - 10*np.cos(2*np.pi*x) + 10) + 260,
     "range": [-2, 5], "dim": 10, "fmin": 260}
]

# Transfer functions
transfer_functions = [
    {"name": "S1", "func": lambda v: 1/(1+np.exp(-v)), "type": "s", "inertia": "increasing"},
    {"name": "S2", "func": lambda v: 1/(1+np.exp(-v)), "type": "s", "inertia": "increasing"},
    {"name": "S3", "func": lambda v: 1/(1+np.exp(-v/2)), "type": "s", "inertia": "increasing"},
    {"name": "S4", "func": lambda v: 1/(1+np.exp(-v/3)), "type": "s", "inertia": "increasing"},
    {"name": "V1", "func": lambda v: np.abs(erf(np.sqrt(np.pi)*v)), "type": "v", "inertia": "decreasing"},
    {"name": "V2", "func": lambda v: np.abs(np.tanh(v)), "type": "v", "inertia": "decreasing"},
    {"name": "V3", "func": lambda v: np.abs(v/np.sqrt(1+v**2)), "type": "v", "inertia": "decreasing"},
    {"name": "V4", "func": lambda v: np.abs(2/np.pi*np.arctan(np.pi/2*v)), "type": "v", "inertia": "decreasing"},
    {"name": "V5", "func": lambda v: 2/np.pi*np.arctan(v**2), "type": "v", "inertia": "decreasing"},
    {"name": "V6", "func": lambda v: 1-np.exp(-v/2), "type": "v", "inertia": "decreasing"}
]

def binary_pso(func_info, transfer_func, num_particles=30, max_iter=500, runs=20):
    dim = func_info["dim"]
    search_range = func_info["range"]
    func = func_info["func"]
    c1, c2 = 1.49, 1.49
    w_initial, w_final = 1.1, 0.1
    
    all_best_fitness = np.zeros((runs, max_iter))
    all_final_fitness = np.zeros(runs)
    execution_times = np.zeros(runs)
    
    for run in range(runs):
        start_time = time.time()
        
        particles = np.random.uniform(search_range[0], search_range[1], (num_particles, dim))
        velocities = np.zeros((num_particles, dim))
        personal_best_positions = particles.copy()
        personal_best_scores = np.array([func(p) for p in particles])
        
        global_best_idx = np.argmin(personal_best_scores)
        global_best_position = personal_best_positions[global_best_idx].copy()
        global_best_score = personal_best_scores[global_best_idx]
        
        for iter in range(max_iter):
            if transfer_func["inertia"] == "increasing":
                w = w_final + (w_initial - w_final) * iter / max_iter
            else:
                w = w_initial - (w_initial - w_final) * iter / max_iter
            
            for i in range(num_particles):
                r1, r2 = np.random.random(dim), np.random.random(dim)
                velocities[i] = w * velocities[i] + \
                              c1 * r1 * (personal_best_positions[i] - particles[i]) + \
                              c2 * r2 * (global_best_position - particles[i])
                
                tf_values = transfer_func["func"](velocities[i])
                
                if transfer_func["type"] == "s":
                    r = np.random.random(dim)
                    particles[i] = np.where(r < tf_values, 
                                          np.random.uniform(search_range[0], search_range[1], dim), 
                                          particles[i])
                else:
                    r = np.random.random(dim)
                    particles[i] = np.where(r < tf_values, 
                                          particles[i] * (1 - tf_values), 
                                          particles[i] * tf_values)
                
                particles[i] = np.clip(particles[i], search_range[0], search_range[1])
                
                current_fitness = func(particles[i])
                
                if current_fitness < personal_best_scores[i]:
                    personal_best_scores[i] = current_fitness
                    personal_best_positions[i] = particles[i].copy()
                    
                    if current_fitness < global_best_score:
                        global_best_score = current_fitness
                        global_best_position = particles[i].copy()
            
            all_best_fitness[run, iter] = global_best_score
        
        all_final_fitness[run] = global_best_score
        execution_times[run] = time.time() - start_time
    
    avg_best_fitness = np.mean(all_best_fitness, axis=0)
    avg_final_fitness = np.mean(all_final_fitness)
    std_final_fitness = np.std(all_final_fitness)
    avg_time = np.mean(execution_times)
    
    return avg_best_fitness, avg_final_fitness, std_final_fitness, avg_time

def generate_convergence_plot(func_name, tf_results):
    plt.figure(figsize=(12, 8))
    
    # Sort transfer functions by final performance
    sorted_tfs = sorted(tf_results.items(), key=lambda x: x[1]["avg_final"])
    
    # Plot all convergence curves
    for tf_name, data in sorted_tfs:
        plt.plot(data["avg_fitness"], label=f"{tf_name} (Final: {data['avg_final']:.2f}±{data['std_final']:.2f})")
    
    # Highlight best and worst
    plt.plot(sorted_tfs[0][1]["avg_fitness"], linewidth=3, color='green', 
            label=f"BEST: {sorted_tfs[0][0]} ({sorted_tfs[0][1]['avg_final']:.2f}±{sorted_tfs[0][1]['std_final']:.2f})")
    plt.plot(sorted_tfs[-1][1]["avg_fitness"], linewidth=3, color='red', 
            label=f"WORST: {sorted_tfs[-1][0]} ({sorted_tfs[-1][1]['avg_final']:.2f}±{sorted_tfs[-1][1]['std_final']:.2f})")
    
    plt.title(f"{func_name}\nConvergence Plot of All Transfer Functions", pad=20)
    plt.xlabel("Iteration")
    plt.ylabel("Fitness Value")
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()
    
    # Save plots
    base_filename = os.path.join(convergence_dir, func_name.replace(":", "_"))
    plt.savefig(f"{base_filename}_convergence.svg", format="svg", bbox_inches='tight')
    plt.savefig(f"{base_filename}_convergence.png", format="png", dpi=300, bbox_inches='tight')
    plt.close()

def generate_performance_plot(func_name, tf_results):
    plt.figure(figsize=(14, 8))
    
    # Sort transfer functions by performance
    sorted_tfs = sorted(tf_results.items(), key=lambda x: x[1]["avg_final"])
    tf_names = [x[0] for x in sorted_tfs]
    final_values = [x[1]["avg_final"] for x in sorted_tfs]
    std_values = [x[1]["std_final"] for x in sorted_tfs]
    times = [x[1]["avg_time"] for x in sorted_tfs]
    
    # Create bar plot with error bars
    bars = plt.bar(range(len(tf_names)), final_values, yerr=std_values, 
                  capsize=5, alpha=0.7)
    
    # Highlight best and worst
    bars[0].set_color('green')
    bars[-1].set_color('red')
    
    # Add time information as text above bars
    for i, (value, time_val) in enumerate(zip(final_values, times)):
        plt.text(i, value + std_values[i] + 0.05*max(final_values), 
                f"{time_val:.2f}s", ha='center', va='bottom', fontsize=9)
    
    plt.xticks(range(len(tf_names)), tf_names, rotation=45)
    plt.xlabel("Transfer Function")
    plt.ylabel("Final Fitness Value")
    plt.title(f"{func_name}\nTransfer Function Performance Comparison\n"
             f"Best: {tf_names[0]} ({final_values[0]:.2f}±{std_values[0]:.2f}), "
             f"Worst: {tf_names[-1]} ({final_values[-1]:.2f}±{std_values[-1]:.2f})", pad=20)
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()
    
    # Save plots
    base_filename = os.path.join(performance_dir, func_name.replace(":", "_"))
    plt.savefig(f"{base_filename}_performance.svg", format="svg", bbox_inches='tight')
    plt.savefig(f"{base_filename}_performance.png", format="png", dpi=300, bbox_inches='tight')
    plt.close()

def save_text_results(func_name, tf_results):
    # Sort by performance
    sorted_tfs = sorted(tf_results.items(), key=lambda x: x[1]["avg_final"])
    
    with open(os.path.join(results_dir, f"{func_name.replace(':', '_')}_results.txt"), "w") as f:
        f.write(f"Results for {func_name}\n")
        f.write("="*80 + "\n")
        f.write(f"{'TF':<20}{'Final Fitness':<20}{'Std Dev':<15}{'Time (s)':<15}{'Performance'}\n")
        f.write("-"*80 + "\n")
        
        for i, (tf_name, data) in enumerate(sorted_tfs):
            performance = ""
            if i == 0:
                performance = "BEST"
            elif i == len(sorted_tfs) - 1:
                performance = "WORST"
            
            f.write(f"{tf_name:<20}{data['avg_final']:<20.4f}{data['std_final']:<15.4f}"
                    f"{data['avg_time']:<15.4f}{performance}\n")
        
        f.write("\n\nConvergence Data:\n")
        f.write("Iteration," + ",".join([tf[0] for tf in sorted_tfs]) + "\n")
        
        # Get number of iterations from one of the result entries
        num_iters = len(next(iter(tf_results.values()))["avg_fitness"])
        
        for i in range(num_iters):
            values = [f"{tf[1]['avg_fitness'][i]:.4f}" for tf in sorted_tfs]
            f.write(f"{i}," + ",".join(values) + "\n")

def generate_performance_heatmap(global_results):
    # Prepare data for heatmap
    func_names = [f"F{i+1}" for i in range(len(benchmark_functions))]
    tf_names = [tf["name"] for tf in transfer_functions]
    
    # Create a matrix of performance values
    performance_matrix = np.zeros((len(func_names), len(tf_names)))
    
    for i, func_name in enumerate(global_results.keys()):
        for j, tf_name in enumerate(tf_names):
            performance_matrix[i, j] = global_results[func_name][tf_name]["avg_final"]
    
    # Normalize the performance matrix (0 = best, 1 = worst for each function)
    normalized_matrix = np.zeros_like(performance_matrix)
    for i in range(len(func_names)):
        min_val = np.min(performance_matrix[i])
        max_val = np.max(performance_matrix[i])
        if max_val != min_val:
            normalized_matrix[i] = (performance_matrix[i] - min_val) / (max_val - min_val)
    
    # Create the heatmap
    plt.figure(figsize=(16, 12))
    plt.imshow(normalized_matrix, cmap='RdYlGn_r', aspect='auto', interpolation='nearest')
    
    # Add colorbar
    cbar = plt.colorbar()
    cbar.set_label('Normalized Performance (0=best, 1=worst for each function)')
    
    # Add labels
    plt.xticks(np.arange(len(tf_names)), tf_names, rotation=45)
    plt.yticks(np.arange(len(func_names)), func_names)
    plt.xlabel('Transfer Functions')
    plt.ylabel('Benchmark Functions')
    plt.title('Performance Heatmap of All Transfer Functions Across All Benchmark Functions')
    
    # Add text annotations
    for i in range(len(func_names)):
        for j in range(len(tf_names)):
            plt.text(j, i, f"{performance_matrix[i,j]:.1f}", 
                    ha="center", va="center", color="black", fontsize=8)
    
    plt.tight_layout()
    
    # Save the heatmap
    heatmap_path = os.path.join(main_output_dir, "4_Performance_Heatmap.png")
    plt.savefig(heatmap_path, dpi=300, bbox_inches='tight')
    plt.close()
    
    print(f"Heatmap saved to: {heatmap_path}")

def run_experiments():
    global_results = {}
    
    # Create summary file
    summary_path = os.path.join(results_dir, "00_Summary_Results.txt")
    
    with open(summary_path, "w") as summary_file:
        summary_file.write("BPSO EXPERIMENT SUMMARY\n")
        summary_file.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        summary_file.write(f"Total functions: {len(benchmark_functions)}\n")
        summary_file.write(f"Total transfer functions: {len(transfer_functions)}\n")
        summary_file.write("="*80 + "\n\n")
        
        for func_info in benchmark_functions:
            func_name = func_info["name"]
            short_name = func_name.split(":")[0]
            print(f"\nRunning experiments for {func_name}...")
            
            tf_results = {}
            for tf in transfer_functions:
                print(f"  Testing {tf['name']}...", end=" ", flush=True)
                avg_fitness, avg_final, std_final, avg_time = binary_pso(func_info, tf)
                tf_results[tf["name"]] = {
                    "avg_fitness": avg_fitness,
                    "avg_final": avg_final,
                    "std_final": std_final,
                    "avg_time": avg_time
                }
                print(f"Done. Fitness: {avg_final:.2f}±{std_final:.2f}, Time: {avg_time:.2f}s")
            
            global_results[short_name] = tf_results
            
            # Generate plots and save results
            generate_convergence_plot(func_name, tf_results)
            generate_performance_plot(func_name, tf_results)
            save_text_results(func_name, tf_results)
            
            # Write to summary file
            best_tf = min(tf_results.items(), key=lambda x: x[1]["avg_final"])
            worst_tf = max(tf_results.items(), key=lambda x: x[1]["avg_final"])
            
            summary_file.write(f"{func_name}\n")
            summary_file.write(f"  Best: {best_tf[0]} ({best_tf[1]['avg_final']:.2f}±{best_tf[1]['std_final']:.2f})\n")
            summary_file.write(f"  Worst: {worst_tf[0]} ({worst_tf[1]['avg_final']:.2f}±{worst_tf[1]['std_final']:.2f})\n")
            summary_file.write("-"*60 + "\n")
    
    # Generate performance heatmap after all experiments
    generate_performance_heatmap(global_results)
    
    return global_results

if __name__ == "__main__":
    print(f"Starting comprehensive BPSO experiments...")
    print(f"Results will be saved in: {os.path.abspath(main_output_dir)}")
    
    results = run_experiments()
    
    print("\nExperiment completed successfully!")
    print(f"All results saved in: {os.path.abspath(main_output_dir)}")
    print("Folder structure:")
    print(f"  1. Convergence plots: {os.path.abspath(convergence_dir)}")
    print(f"  2. Results data: {os.path.abspath(results_dir)}")
    print(f"  3. Performance plots: {os.path.abspath(performance_dir)}")
    print(f"  4. Performance heatmap: {os.path.abspath(main_output_dir)}/4_Performance_Heatmap.png")
